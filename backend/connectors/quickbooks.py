"""
QuickBooks Online Connector

Handles OAuth authentication and invoice creation for QuickBooks Online.
Never auto-posts without explicit approval.

Design Notes:
- In production, implement actual QuickBooks API calls
- Use the QuickBooks Python SDK or direct REST API
- Handle token refresh automatically
- Map Crafta fields to QuickBooks schema
"""

import os
from datetime import datetime
from typing import Optional, Dict, Any, List
import logging

logger = logging.getLogger(__name__)


class QuickBooksConnector:
    """
    QuickBooks Online connector for invoice creation.

    Field Mapping (Crafta → QuickBooks):
    - customer_ref → CustomerRef.value
    - invoice_date → TxnDate
    - due_date → DueDate
    - line.description → Line[].Description
    - line.quantity → Line[].SalesItemLineDetail.Qty
    - line.unit_price → Line[].SalesItemLineDetail.UnitPrice
    - line.amount → Line[].Amount
    - memo → PrivateNote
    """

    BASE_URL = "https://quickbooks.api.intuit.com/v3/company"
    AUTH_URL = "https://appcenter.intuit.com/connect/oauth2"
    TOKEN_URL = "https://oauth.platform.intuit.com/oauth2/v1/tokens/bearer"

    def __init__(
        self,
        client_id: Optional[str] = None,
        client_secret: Optional[str] = None,
        redirect_uri: Optional[str] = None,
    ):
        self.client_id = client_id or os.getenv("QUICKBOOKS_CLIENT_ID")
        self.client_secret = client_secret or os.getenv("QUICKBOOKS_CLIENT_SECRET")
        self.redirect_uri = redirect_uri or os.getenv("QUICKBOOKS_REDIRECT_URI")

        self.access_token: Optional[str] = None
        self.refresh_token: Optional[str] = None
        self.realm_id: Optional[str] = None
        self.token_expires_at: Optional[datetime] = None

    def get_auth_url(self, state: str) -> str:
        """Generate OAuth authorization URL"""
        params = {
            "client_id": self.client_id,
            "response_type": "code",
            "scope": "com.intuit.quickbooks.accounting",
            "redirect_uri": self.redirect_uri,
            "state": state,
        }
        query = "&".join(f"{k}={v}" for k, v in params.items())
        return f"{self.AUTH_URL}?{query}"

    async def exchange_code(self, code: str, realm_id: str) -> Dict[str, Any]:
        """
        Exchange authorization code for access token.

        In production, implement actual HTTP call to TOKEN_URL.
        """
        # TODO: Implement actual token exchange
        # import httpx
        # async with httpx.AsyncClient() as client:
        #     response = await client.post(self.TOKEN_URL, ...)

        # Mock response for development
        self.access_token = f"mock_access_{code[:8]}"
        self.refresh_token = f"mock_refresh_{code[:8]}"
        self.realm_id = realm_id

        logger.info(f"QuickBooks connected: realm_id={realm_id}")

        return {
            "access_token": self.access_token,
            "refresh_token": self.refresh_token,
            "realm_id": realm_id,
        }

    async def refresh_access_token(self) -> bool:
        """Refresh the access token using refresh token"""
        if not self.refresh_token:
            return False

        # TODO: Implement actual token refresh
        logger.info("QuickBooks token refreshed")
        return True

    def validate_auth(self) -> bool:
        """Check if authentication is valid"""
        return bool(self.access_token and self.realm_id)

    def build_invoice_payload(
        self,
        invoice: Dict[str, Any],
        customer_ref: str,
    ) -> Dict[str, Any]:
        """
        Build QuickBooks invoice payload from Crafta invoice.

        QuickBooks Invoice Schema:
        {
            "CustomerRef": {"value": "123"},
            "TxnDate": "2026-01-20",
            "DueDate": "2026-02-19",
            "Line": [
                {
                    "DetailType": "SalesItemLineDetail",
                    "Amount": 200.00,
                    "SalesItemLineDetail": {
                        "ItemRef": {"value": "1"},
                        "Qty": 10,
                        "UnitPrice": 20.00
                    },
                    "Description": "Consulting services"
                }
            ],
            "PrivateNote": "Generated by Crafta"
        }
        """
        lines = []
        for line in invoice.get("lines", []):
            qb_line = {
                "DetailType": "SalesItemLineDetail",
                "Amount": float(line.get("amount", 0)),
                "SalesItemLineDetail": {
                    "Qty": float(line.get("quantity", 0)),
                    "UnitPrice": float(line.get("unit_price", 0)),
                },
                "Description": line.get("description", ""),
            }
            lines.append(qb_line)

        payload = {
            "CustomerRef": {"value": customer_ref},
            "TxnDate": invoice.get("invoice_date", datetime.utcnow().strftime("%Y-%m-%d")),
            "Line": lines,
            "PrivateNote": f"Crafta Invoice: {invoice.get('invoice_id', '')}",
        }

        if invoice.get("due_date"):
            payload["DueDate"] = invoice["due_date"][:10]

        return payload

    async def create_invoice(
        self,
        payload: Dict[str, Any],
        approval_id: str,
    ) -> Dict[str, Any]:
        """
        Create invoice in QuickBooks.

        CRITICAL: This should only be called after human approval.
        The approval_id must be validated before calling.

        In production, implement actual API call.
        """
        if not self.validate_auth():
            raise ValueError("QuickBooks not authenticated")

        # TODO: Implement actual API call
        # url = f"{self.BASE_URL}/{self.realm_id}/invoice"
        # async with httpx.AsyncClient() as client:
        #     response = await client.post(url, json=payload, headers=...)

        # Mock response
        timestamp = datetime.utcnow().strftime("%Y%m%d%H%M%S")
        qb_invoice_id = f"QB-{timestamp}"

        logger.info(f"Invoice created in QuickBooks: {qb_invoice_id}")

        return {
            "erp_invoice_id": qb_invoice_id,
            "status": "created",
            "payload": payload,
        }

    async def get_customers(
        self,
        search: Optional[str] = None,
        limit: int = 50,
    ) -> List[Dict[str, Any]]:
        """
        Get customer list from QuickBooks.

        In production, implement actual API call.
        """
        if not self.validate_auth():
            raise ValueError("QuickBooks not authenticated")

        # TODO: Implement actual API call
        # Mock response
        customers = [
            {"id": "1", "name": "Acme Corp", "email": "billing@acme.com"},
            {"id": "2", "name": "BlueCo Inc", "email": "ap@blueco.com"},
        ]

        if search:
            customers = [c for c in customers if search.lower() in c["name"].lower()]

        return customers[:limit]

    async def void_invoice(self, invoice_id: str) -> bool:
        """
        Void an invoice in QuickBooks.

        Used for rollback when approval is revoked.
        """
        if not self.validate_auth():
            raise ValueError("QuickBooks not authenticated")

        # TODO: Implement actual void operation
        logger.info(f"Invoice voided in QuickBooks: {invoice_id}")
        return True
